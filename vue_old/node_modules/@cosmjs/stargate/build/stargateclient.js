"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StargateClient = exports.coinFromProto = exports.accountFromProto = exports.assertIsBroadcastTxSuccess = exports.isBroadcastTxSuccess = exports.isBroadcastTxFailure = void 0;
/* eslint-disable @typescript-eslint/naming-convention */
const encoding_1 = require("@cosmjs/encoding");
const launchpad_1 = require("@cosmjs/launchpad");
const math_1 = require("@cosmjs/math");
const proto_signing_1 = require("@cosmjs/proto-signing");
const tendermint_rpc_1 = require("@cosmjs/tendermint-rpc");
const utils_1 = require("@cosmjs/utils");
const abci_1 = require("./codec/cosmos/base/abci/v1beta1/abci");
const queries_1 = require("./queries");
function isBroadcastTxFailure(result) {
    return !!result.code;
}
exports.isBroadcastTxFailure = isBroadcastTxFailure;
function isBroadcastTxSuccess(result) {
    return !isBroadcastTxFailure(result);
}
exports.isBroadcastTxSuccess = isBroadcastTxSuccess;
/**
 * Ensures the given result is a success. Throws a detailed error message otherwise.
 */
function assertIsBroadcastTxSuccess(result) {
    if (isBroadcastTxFailure(result)) {
        throw new Error(`Error when broadcasting tx ${result.transactionHash} at height ${result.height}. Code: ${result.code}; Raw log: ${result.rawLog}`);
    }
}
exports.assertIsBroadcastTxSuccess = assertIsBroadcastTxSuccess;
function uint64FromProto(input) {
    if (!input)
        return math_1.Uint64.fromNumber(0);
    return math_1.Uint64.fromString(input.toString());
}
function accountFromProto(input) {
    const { address, pubKey, accountNumber, sequence } = input;
    const pubkey = proto_signing_1.decodePubkey(pubKey);
    utils_1.assert(address);
    return {
        address: address,
        pubkey: pubkey,
        accountNumber: uint64FromProto(accountNumber).toNumber(),
        sequence: uint64FromProto(sequence).toNumber(),
    };
}
exports.accountFromProto = accountFromProto;
function coinFromProto(input) {
    utils_1.assertDefinedAndNotNull(input.amount);
    utils_1.assertDefinedAndNotNull(input.denom);
    return {
        amount: input.amount,
        denom: input.denom,
    };
}
exports.coinFromProto = coinFromProto;
class StargateClient {
    constructor(tmClient) {
        this.tmClient = tmClient;
        this.queryClient = queries_1.QueryClient.withExtensions(tmClient, queries_1.setupAuthExtension, queries_1.setupBankExtension);
    }
    static async connect(endpoint) {
        const tmClient = await tendermint_rpc_1.Tendermint34Client.connect(endpoint);
        return new StargateClient(tmClient);
    }
    async getChainId() {
        if (!this.chainId) {
            const response = await this.tmClient.status();
            const chainId = response.nodeInfo.network;
            if (!chainId)
                throw new Error("Chain ID must not be empty");
            this.chainId = chainId;
        }
        return this.chainId;
    }
    async getHeight() {
        const status = await this.tmClient.status();
        return status.syncInfo.latestBlockHeight;
    }
    // this is nice to display data to the user, but is slower
    async getAccount(searchAddress) {
        const account = await this.queryClient.auth.account(searchAddress);
        return account ? accountFromProto(account) : null;
    }
    // if we just need to get the sequence for signing a transaction, let's make this faster
    // (no need to wait a block before submitting)
    async getAccountUnverified(searchAddress) {
        const account = await this.queryClient.auth.unverified.account(searchAddress);
        return account ? accountFromProto(account) : null;
    }
    async getSequence(address) {
        const account = await this.getAccount(address);
        if (account) {
            return {
                accountNumber: account.accountNumber,
                sequence: account.sequence,
            };
        }
        else {
            return null;
        }
    }
    async getBlock(height) {
        const response = await this.tmClient.block(height);
        return {
            id: encoding_1.toHex(response.blockId.hash).toUpperCase(),
            header: {
                version: {
                    block: new math_1.Uint53(response.block.header.version.block).toString(),
                    app: new math_1.Uint53(response.block.header.version.app).toString(),
                },
                height: response.block.header.height,
                chainId: response.block.header.chainId,
                time: tendermint_rpc_1.toRfc3339WithNanoseconds(response.block.header.time),
            },
            txs: response.block.txs,
        };
    }
    async getBalance(address, searchDenom) {
        const balance = await this.queryClient.bank.balance(address, searchDenom);
        return balance ? coinFromProto(balance) : null;
    }
    /**
     * Queries all balances for all denoms that belong to this address.
     *
     * Uses the grpc queries (which iterates over the store internally), and we cannot get
     * proofs from such a method.
     */
    async getAllBalancesUnverified(address) {
        const balances = await this.queryClient.bank.unverified.allBalances(address);
        return balances.map(coinFromProto);
    }
    async getTx(id) {
        var _a;
        const results = await this.txsQuery(`tx.hash='${id}'`);
        return (_a = results[0]) !== null && _a !== void 0 ? _a : null;
    }
    async searchTx(query, filter = {}) {
        const minHeight = filter.minHeight || 0;
        const maxHeight = filter.maxHeight || Number.MAX_SAFE_INTEGER;
        if (maxHeight < minHeight)
            return []; // optional optimization
        function withFilters(originalQuery) {
            return `${originalQuery} AND tx.height>=${minHeight} AND tx.height<=${maxHeight}`;
        }
        let txs;
        if (launchpad_1.isSearchByHeightQuery(query)) {
            txs =
                query.height >= minHeight && query.height <= maxHeight
                    ? await this.txsQuery(`tx.height=${query.height}`)
                    : [];
        }
        else if (launchpad_1.isSearchBySentFromOrToQuery(query)) {
            const sentQuery = withFilters(`message.module='bank' AND transfer.sender='${query.sentFromOrTo}'`);
            const receivedQuery = withFilters(`message.module='bank' AND transfer.recipient='${query.sentFromOrTo}'`);
            const [sent, received] = await Promise.all([sentQuery, receivedQuery].map((rawQuery) => this.txsQuery(rawQuery)));
            const sentHashes = sent.map((t) => t.hash);
            txs = [...sent, ...received.filter((t) => !sentHashes.includes(t.hash))];
        }
        else if (launchpad_1.isSearchByTagsQuery(query)) {
            const rawQuery = withFilters(query.tags.map((t) => `${t.key}='${t.value}'`).join(" AND "));
            txs = await this.txsQuery(rawQuery);
        }
        else {
            throw new Error("Unknown query type");
        }
        const filtered = txs.filter((tx) => tx.height >= minHeight && tx.height <= maxHeight);
        return filtered;
    }
    disconnect() {
        this.tmClient.disconnect();
    }
    async broadcastTx(tx) {
        var _a, _b, _c, _d, _e, _f, _g;
        const response = await this.tmClient.broadcastTxCommit({ tx });
        if (tendermint_rpc_1.broadcastTxCommitSuccess(response)) {
            return {
                height: response.height,
                transactionHash: encoding_1.toHex(response.hash).toUpperCase(),
                rawLog: (_a = response.deliverTx) === null || _a === void 0 ? void 0 : _a.log,
                data: ((_b = response.deliverTx) === null || _b === void 0 ? void 0 : _b.data) ? abci_1.TxMsgData.decode((_c = response.deliverTx) === null || _c === void 0 ? void 0 : _c.data).data : undefined,
            };
        }
        return response.checkTx.code !== 0
            ? {
                height: response.height,
                code: response.checkTx.code,
                transactionHash: encoding_1.toHex(response.hash).toUpperCase(),
                rawLog: response.checkTx.log,
                data: response.checkTx.data ? abci_1.TxMsgData.decode(response.checkTx.data).data : undefined,
            }
            : {
                height: response.height,
                code: (_d = response.deliverTx) === null || _d === void 0 ? void 0 : _d.code,
                transactionHash: encoding_1.toHex(response.hash).toUpperCase(),
                rawLog: (_e = response.deliverTx) === null || _e === void 0 ? void 0 : _e.log,
                data: ((_f = response.deliverTx) === null || _f === void 0 ? void 0 : _f.data) ? abci_1.TxMsgData.decode((_g = response.deliverTx) === null || _g === void 0 ? void 0 : _g.data).data : undefined,
            };
    }
    async txsQuery(query) {
        const results = await this.tmClient.txSearchAll({ query: query });
        return results.txs.map((tx) => {
            return {
                height: tx.height,
                hash: encoding_1.toHex(tx.hash).toUpperCase(),
                code: tx.result.code,
                rawLog: tx.result.log || "",
                tx: tx.tx,
            };
        });
    }
}
exports.StargateClient = StargateClient;
//# sourceMappingURL=stargateclient.js.map