"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SigningStargateClient = exports.defaultRegistryTypes = void 0;
const encoding_1 = require("@cosmjs/encoding");
const launchpad_1 = require("@cosmjs/launchpad");
const math_1 = require("@cosmjs/math");
const proto_signing_1 = require("@cosmjs/proto-signing");
const tendermint_rpc_1 = require("@cosmjs/tendermint-rpc");
const aminotypes_1 = require("./aminotypes");
const tx_1 = require("./codec/cosmos/bank/v1beta1/tx");
const tx_2 = require("./codec/cosmos/distribution/v1beta1/tx");
const tx_3 = require("./codec/cosmos/staking/v1beta1/tx");
const signing_1 = require("./codec/cosmos/tx/signing/v1beta1/signing");
const tx_4 = require("./codec/cosmos/tx/v1beta1/tx");
const stargateclient_1 = require("./stargateclient");
const defaultGasPrice = launchpad_1.GasPrice.fromString("0.025ucosm");
const defaultGasLimits = { send: 80000 };
exports.defaultRegistryTypes = [
    ["/cosmos.bank.v1beta1.MsgMultiSend", tx_1.MsgMultiSend],
    ["/cosmos.distribution.v1beta1.MsgFundCommunityPool", tx_2.MsgFundCommunityPool],
    ["/cosmos.distribution.v1beta1.MsgSetWithdrawAddress", tx_2.MsgSetWithdrawAddress],
    ["/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward", tx_2.MsgWithdrawDelegatorReward],
    ["/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission", tx_2.MsgWithdrawValidatorCommission],
    ["/cosmos.staking.v1beta1.MsgBeginRedelegate", tx_3.MsgBeginRedelegate],
    ["/cosmos.staking.v1beta1.MsgCreateValidator", tx_3.MsgCreateValidator],
    ["/cosmos.staking.v1beta1.MsgDelegate", tx_3.MsgDelegate],
    ["/cosmos.staking.v1beta1.MsgEditValidator", tx_3.MsgEditValidator],
    ["/cosmos.staking.v1beta1.MsgUndelegate", tx_3.MsgUndelegate],
];
function createDefaultRegistry() {
    return new proto_signing_1.Registry(exports.defaultRegistryTypes);
}
class SigningStargateClient extends stargateclient_1.StargateClient {
    constructor(tmClient, signer, options) {
        super(tmClient);
        const { registry = createDefaultRegistry(), aminoTypes = new aminotypes_1.AminoTypes({ prefix: options.prefix }), gasPrice = defaultGasPrice, gasLimits = defaultGasLimits, } = options;
        this.fees = launchpad_1.buildFeeTable(gasPrice, defaultGasLimits, gasLimits);
        this.registry = registry;
        this.aminoTypes = aminoTypes;
        this.signer = signer;
    }
    static async connectWithSigner(endpoint, signer, options = {}) {
        const tmClient = await tendermint_rpc_1.Tendermint34Client.connect(endpoint);
        return new SigningStargateClient(tmClient, signer, options);
    }
    async sendTokens(senderAddress, recipientAddress, transferAmount, memo = "") {
        const sendMsg = {
            typeUrl: "/cosmos.bank.v1beta1.MsgSend",
            value: {
                fromAddress: senderAddress,
                toAddress: recipientAddress,
                amount: transferAmount,
            },
        };
        return this.signAndBroadcast(senderAddress, [sendMsg], this.fees.send, memo);
    }
    async signAndBroadcast(signerAddress, messages, fee, memo = "") {
        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
        if (!accountFromSigner) {
            throw new Error("Failed to retrieve account from signer");
        }
        const pubkey = launchpad_1.encodeSecp256k1Pubkey(accountFromSigner.pubkey);
        const accountFromChain = await this.getAccountUnverified(signerAddress);
        if (!accountFromChain) {
            throw new Error("Account not found");
        }
        const { accountNumber, sequence } = accountFromChain;
        if (!pubkey) {
            throw new Error("Pubkey not known");
        }
        const chainId = await this.getChainId();
        const pubkeyAny = proto_signing_1.encodePubkey(pubkey);
        const txBody = {
            messages: messages,
            memo: memo,
        };
        const txBodyBytes = this.registry.encode({
            typeUrl: "/cosmos.tx.v1beta1.TxBody",
            value: txBody,
        });
        const gasLimit = math_1.Int53.fromString(fee.gas).toNumber();
        if (proto_signing_1.isOfflineDirectSigner(this.signer)) {
            const authInfoBytes = proto_signing_1.makeAuthInfoBytes([pubkeyAny], fee.amount, gasLimit, sequence);
            const signDoc = proto_signing_1.makeSignDoc(txBodyBytes, authInfoBytes, chainId, accountNumber);
            const { signature, signed } = await this.signer.signDirect(signerAddress, signDoc);
            const txRaw = tx_4.TxRaw.fromPartial({
                bodyBytes: signed.bodyBytes,
                authInfoBytes: signed.authInfoBytes,
                signatures: [encoding_1.fromBase64(signature.signature)],
            });
            const signedTx = Uint8Array.from(tx_4.TxRaw.encode(txRaw).finish());
            return this.broadcastTx(signedTx);
        }
        // Amino signer
        const signMode = signing_1.SignMode.SIGN_MODE_LEGACY_AMINO_JSON;
        const msgs = messages.map((msg) => this.aminoTypes.toAmino(msg));
        const signDoc = launchpad_1.makeSignDoc(msgs, fee, chainId, memo, accountNumber, sequence);
        const { signature, signed } = await this.signer.signAmino(signerAddress, signDoc);
        const signedTxBody = {
            messages: signed.msgs.map((msg) => this.aminoTypes.fromAmino(msg)),
            memo: signed.memo,
        };
        const signedTxBodyBytes = this.registry.encode({
            typeUrl: "/cosmos.tx.v1beta1.TxBody",
            value: signedTxBody,
        });
        const signedGasLimit = math_1.Int53.fromString(signed.fee.gas).toNumber();
        const signedSequence = math_1.Int53.fromString(signed.sequence).toNumber();
        const signedAuthInfoBytes = proto_signing_1.makeAuthInfoBytes([pubkeyAny], signed.fee.amount, signedGasLimit, signedSequence, signMode);
        const txRaw = tx_4.TxRaw.fromPartial({
            bodyBytes: signedTxBodyBytes,
            authInfoBytes: signedAuthInfoBytes,
            signatures: [encoding_1.fromBase64(signature.signature)],
        });
        const signedTx = Uint8Array.from(tx_4.TxRaw.encode(txRaw).finish());
        return this.broadcastTx(signedTx);
    }
}
exports.SigningStargateClient = SigningStargateClient;
//# sourceMappingURL=signingstargateclient.js.map