"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/naming-convention */
const launchpad_1 = require("@cosmjs/launchpad");
const proto_signing_1 = require("@cosmjs/proto-signing");
const tendermint_rpc_1 = require("@cosmjs/tendermint-rpc");
const utils_1 = require("@cosmjs/utils");
const signingstargateclient_1 = require("../signingstargateclient");
const stargateclient_1 = require("../stargateclient");
const testutils_spec_1 = require("../testutils.spec");
const queryclient_1 = require("./queryclient");
const staking_1 = require("./staking");
async function makeClientWithStaking(rpcUrl) {
    const tmClient = await tendermint_rpc_1.Tendermint34Client.connect(rpcUrl);
    return [queryclient_1.QueryClient.withExtensions(tmClient, staking_1.setupStakingExtension), tmClient];
}
describe("StakingExtension", () => {
    const defaultFee = {
        amount: launchpad_1.coins(25000, "ucosm"),
        gas: "1500000",
    };
    beforeAll(async () => {
        if (testutils_spec_1.simappEnabled()) {
            const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.faucet.mnemonic);
            const client = await signingstargateclient_1.SigningStargateClient.connectWithSigner(testutils_spec_1.simapp.tendermintUrl, wallet);
            {
                const msg = {
                    delegatorAddress: testutils_spec_1.faucet.address0,
                    validatorAddress: testutils_spec_1.validator.validatorAddress,
                    amount: launchpad_1.coin(25000, "ustake"),
                };
                const msgAny = {
                    typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
                    value: msg,
                };
                const memo = "Test delegation for Stargate";
                const result = await client.signAndBroadcast(testutils_spec_1.faucet.address0, [msgAny], defaultFee, memo);
                stargateclient_1.assertIsBroadcastTxSuccess(result);
            }
            {
                const msg = {
                    delegatorAddress: testutils_spec_1.faucet.address0,
                    validatorAddress: testutils_spec_1.validator.validatorAddress,
                    amount: launchpad_1.coin(100, "ustake"),
                };
                const msgAny = {
                    typeUrl: "/cosmos.staking.v1beta1.MsgUndelegate",
                    value: msg,
                };
                const memo = "Test undelegation for Stargate";
                const result = await client.signAndBroadcast(testutils_spec_1.faucet.address0, [msgAny], defaultFee, memo);
                stargateclient_1.assertIsBroadcastTxSuccess(result);
            }
            await utils_1.sleep(75); // wait until transactions are indexed
        }
    });
    describe("unverified", () => {
        describe("delegation", () => {
            it("works", async () => {
                testutils_spec_1.pendingWithoutSimapp();
                const [client, tmClient] = await makeClientWithStaking(testutils_spec_1.simapp.tendermintUrl);
                const response = await client.staking.unverified.delegation(testutils_spec_1.faucet.address0, testutils_spec_1.validator.validatorAddress);
                expect(response.delegationResponse).toBeDefined();
                expect(response.delegationResponse).not.toBeNull();
                tmClient.disconnect();
            });
        });
        describe("delegatorDelegations", () => {
            it("works", async () => {
                testutils_spec_1.pendingWithoutSimapp();
                const [client, tmClient] = await makeClientWithStaking(testutils_spec_1.simapp.tendermintUrl);
                const response = await client.staking.unverified.delegatorDelegations(testutils_spec_1.faucet.address0);
                expect(response.delegationResponses).toBeDefined();
                expect(response.delegationResponses).not.toBeNull();
                tmClient.disconnect();
            });
        });
        describe("delegatorUnbondingDelegations", () => {
            it("works", async () => {
                testutils_spec_1.pendingWithoutSimapp();
                const [client, tmClient] = await makeClientWithStaking(testutils_spec_1.simapp.tendermintUrl);
                const response = await client.staking.unverified.delegatorUnbondingDelegations(testutils_spec_1.faucet.address0);
                expect(response.unbondingResponses).toBeDefined();
                expect(response.unbondingResponses).not.toBeNull();
                tmClient.disconnect();
            });
        });
        describe("delegatorValidator", () => {
            it("works", async () => {
                testutils_spec_1.pendingWithoutSimapp();
                const [client, tmClient] = await makeClientWithStaking(testutils_spec_1.simapp.tendermintUrl);
                const response = await client.staking.unverified.delegatorValidator(testutils_spec_1.faucet.address0, testutils_spec_1.validator.validatorAddress);
                expect(response.validator).toBeDefined();
                expect(response.validator).not.toBeNull();
                tmClient.disconnect();
            });
        });
        describe("delegatorValidators", () => {
            it("works", async () => {
                testutils_spec_1.pendingWithoutSimapp();
                const [client, tmClient] = await makeClientWithStaking(testutils_spec_1.simapp.tendermintUrl);
                const response = await client.staking.unverified.delegatorValidators(testutils_spec_1.faucet.address0);
                expect(response.validators).toBeDefined();
                expect(response.validators).not.toBeNull();
                tmClient.disconnect();
            });
        });
        describe("historicalInfo", () => {
            it("works", async () => {
                testutils_spec_1.pendingWithoutSimapp();
                const [client, tmClient] = await makeClientWithStaking(testutils_spec_1.simapp.tendermintUrl);
                const response = await client.staking.unverified.historicalInfo(5);
                expect(response.hist).toBeDefined();
                expect(response.hist).not.toBeNull();
                tmClient.disconnect();
            });
        });
        describe("params", () => {
            it("works", async () => {
                testutils_spec_1.pendingWithoutSimapp();
                const [client, tmClient] = await makeClientWithStaking(testutils_spec_1.simapp.tendermintUrl);
                const response = await client.staking.unverified.params();
                expect(response.params).toBeDefined();
                expect(response.params).not.toBeNull();
                tmClient.disconnect();
            });
        });
        describe("pool", () => {
            it("works", async () => {
                testutils_spec_1.pendingWithoutSimapp();
                const [client, tmClient] = await makeClientWithStaking(testutils_spec_1.simapp.tendermintUrl);
                const response = await client.staking.unverified.pool();
                expect(response.pool).toBeDefined();
                expect(response.pool).not.toBeNull();
                tmClient.disconnect();
            });
        });
        describe("redelegations", () => {
            it("works", async () => {
                // TODO: Set up a result for this test
                testutils_spec_1.pendingWithoutSimapp();
                const [client, tmClient] = await makeClientWithStaking(testutils_spec_1.simapp.tendermintUrl);
                await expectAsync(client.staking.unverified.redelegations(testutils_spec_1.faucet.address0, testutils_spec_1.validator.validatorAddress, testutils_spec_1.validator.validatorAddress)).toBeRejectedWithError(/redelegation not found/i);
                tmClient.disconnect();
            });
        });
        describe("unbondingDelegation", () => {
            it("works", async () => {
                testutils_spec_1.pendingWithoutSimapp();
                const [client, tmClient] = await makeClientWithStaking(testutils_spec_1.simapp.tendermintUrl);
                const response = await client.staking.unverified.unbondingDelegation(testutils_spec_1.faucet.address0, testutils_spec_1.validator.validatorAddress);
                expect(response.unbond).toBeDefined();
                expect(response.unbond).not.toBeNull();
                tmClient.disconnect();
            });
        });
        describe("validator", () => {
            it("works", async () => {
                testutils_spec_1.pendingWithoutSimapp();
                const [client, tmClient] = await makeClientWithStaking(testutils_spec_1.simapp.tendermintUrl);
                const response = await client.staking.unverified.validator(testutils_spec_1.validator.validatorAddress);
                expect(response.validator).toBeDefined();
                expect(response.validator).not.toBeNull();
                tmClient.disconnect();
            });
        });
        describe("validatorDelegations", () => {
            it("works", async () => {
                testutils_spec_1.pendingWithoutSimapp();
                const [client, tmClient] = await makeClientWithStaking(testutils_spec_1.simapp.tendermintUrl);
                const response = await client.staking.unverified.validatorDelegations(testutils_spec_1.validator.validatorAddress);
                expect(response.delegationResponses).toBeDefined();
                expect(response.delegationResponses).not.toBeNull();
                tmClient.disconnect();
            });
        });
        describe("validators", () => {
            it("works", async () => {
                testutils_spec_1.pendingWithoutSimapp();
                const [client, tmClient] = await makeClientWithStaking(testutils_spec_1.simapp.tendermintUrl);
                const response = await client.staking.unverified.validators("BOND_STATUS_BONDED");
                expect(response.validators).toBeDefined();
                expect(response.validators).not.toBeNull();
                tmClient.disconnect();
            });
        });
        describe("validatorUnbondingDelegations", () => {
            it("works", async () => {
                testutils_spec_1.pendingWithoutSimapp();
                const [client, tmClient] = await makeClientWithStaking(testutils_spec_1.simapp.tendermintUrl);
                const response = await client.staking.unverified.validatorUnbondingDelegations(testutils_spec_1.validator.validatorAddress);
                expect(response.unbondingResponses).toBeDefined();
                expect(response.unbondingResponses).not.toBeNull();
                tmClient.disconnect();
            });
        });
    });
});
//# sourceMappingURL=staking.spec.js.map