"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const tendermint_rpc_1 = require("@cosmjs/tendermint-rpc");
const long_1 = __importDefault(require("long"));
const testutils_spec_1 = require("../testutils.spec");
const ibc_1 = require("./ibc");
const ibcTest = __importStar(require("./ibctestdata.spec"));
const queryclient_1 = require("./queryclient");
async function makeClientWithIbc(rpcUrl) {
    const tmClient = await tendermint_rpc_1.Tendermint34Client.connect(rpcUrl);
    return [queryclient_1.QueryClient.withExtensions(tmClient, ibc_1.setupIbcExtension), tmClient];
}
describe("IbcExtension", () => {
    describe("unverified", () => {
        describe("channel", () => {
            it("works", async () => {
                testutils_spec_1.pendingWithoutSimapp();
                const [client, tmClient] = await makeClientWithIbc(testutils_spec_1.simapp.tendermintUrl);
                const response = await client.ibc.unverified.channel(ibcTest.portId, ibcTest.channelId);
                expect(response.channel).toEqual(ibcTest.channel);
                expect(response.proofHeight).toBeDefined();
                expect(response.proofHeight).not.toBeNull();
                tmClient.disconnect();
            });
        });
        describe("channels", () => {
            it("works", async () => {
                testutils_spec_1.pendingWithoutSimapp();
                const [client, tmClient] = await makeClientWithIbc(testutils_spec_1.simapp.tendermintUrl);
                const response = await client.ibc.unverified.channels();
                expect(response.channels).toEqual([ibcTest.identifiedChannel]);
                expect(response.pagination).toBeDefined();
                expect(response.pagination).not.toBeNull();
                expect(response.height).toBeDefined();
                expect(response.height).not.toBeNull();
                tmClient.disconnect();
            });
        });
        describe("connectionChannels", () => {
            it("works", async () => {
                testutils_spec_1.pendingWithoutSimapp();
                const [client, tmClient] = await makeClientWithIbc(testutils_spec_1.simapp.tendermintUrl);
                const response = await client.ibc.unverified.connectionChannels(ibcTest.connectionId);
                expect(response.channels).toEqual([ibcTest.identifiedChannel]);
                expect(response.pagination).toBeDefined();
                expect(response.pagination).not.toBeNull();
                expect(response.height).toBeDefined();
                expect(response.height).not.toBeNull();
                tmClient.disconnect();
            });
        });
        describe("packetCommitment", () => {
            it("works", async () => {
                testutils_spec_1.pendingWithoutSimapp();
                const [client, tmClient] = await makeClientWithIbc(testutils_spec_1.simapp.tendermintUrl);
                const response = await client.ibc.unverified.packetCommitment(ibcTest.portId, ibcTest.channelId, ibcTest.commitment.sequence);
                expect(response.commitment).toEqual(ibcTest.commitment.data);
                expect(response.proofHeight).toBeDefined();
                expect(response.proofHeight).not.toBeNull();
                tmClient.disconnect();
            });
        });
        describe("packetCommitments", () => {
            it("works", async () => {
                testutils_spec_1.pendingWithoutSimapp();
                const [client, tmClient] = await makeClientWithIbc(testutils_spec_1.simapp.tendermintUrl);
                const response = await client.ibc.unverified.packetCommitments(ibcTest.portId, ibcTest.channelId);
                expect(response.commitments).toEqual([ibcTest.packetState]);
                expect(response.pagination).toBeDefined();
                expect(response.pagination).not.toBeNull();
                expect(response.height).toBeDefined();
                expect(response.height).not.toBeNull();
                tmClient.disconnect();
            });
        });
        describe("packetAcknowledgement", () => {
            it("works", async () => {
                pending("We don't have an acknowledgement for testing at the moment");
                testutils_spec_1.pendingWithoutSimapp();
                const [client, tmClient] = await makeClientWithIbc(testutils_spec_1.simapp.tendermintUrl);
                const response = await client.ibc.unverified.packetAcknowledgement(ibcTest.portId, ibcTest.channelId, ibcTest.commitment.sequence);
                expect(response.acknowledgement).toEqual(ibcTest.packetAcknowledgements[0].data);
                expect(response.proofHeight).toBeDefined();
                expect(response.proofHeight).not.toBeNull();
                tmClient.disconnect();
            });
        });
        describe("packetAcknowledgements", () => {
            it("works", async () => {
                testutils_spec_1.pendingWithoutSimapp();
                const [client, tmClient] = await makeClientWithIbc(testutils_spec_1.simapp.tendermintUrl);
                const response = await client.ibc.unverified.packetAcknowledgements(ibcTest.portId, ibcTest.channelId);
                expect(response.acknowledgements).toEqual(ibcTest.packetAcknowledgements);
                expect(response.pagination).toBeDefined();
                expect(response.pagination).not.toBeNull();
                expect(response.height).toBeDefined();
                expect(response.height).not.toBeNull();
                tmClient.disconnect();
            });
        });
        describe("unreceivedPackets", () => {
            it("works", async () => {
                testutils_spec_1.pendingWithoutSimapp();
                const [client, tmClient] = await makeClientWithIbc(testutils_spec_1.simapp.tendermintUrl);
                const response = await client.ibc.unverified.unreceivedPackets(ibcTest.portId, ibcTest.channelId, [
                    1,
                    2,
                    3,
                ]);
                expect(response.sequences).toEqual([1, 2, 3].map((n) => long_1.default.fromInt(n, true)));
                expect(response.height).toBeDefined();
                expect(response.height).not.toBeNull();
                tmClient.disconnect();
            });
        });
        describe("unreceivedAcks", () => {
            it("works", async () => {
                testutils_spec_1.pendingWithoutSimapp();
                const [client, tmClient] = await makeClientWithIbc(testutils_spec_1.simapp.tendermintUrl);
                const response = await client.ibc.unverified.unreceivedAcks(ibcTest.portId, ibcTest.channelId, [
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                ]);
                expect(response.sequences).toEqual([long_1.default.fromInt(ibcTest.commitment.sequence, true)]);
                expect(response.height).toBeDefined();
                expect(response.height).not.toBeNull();
                tmClient.disconnect();
            });
        });
        describe("nextSequenceReceive", () => {
            it("works", async () => {
                testutils_spec_1.pendingWithoutSimapp();
                const [client, tmClient] = await makeClientWithIbc(testutils_spec_1.simapp.tendermintUrl);
                const response = await client.ibc.unverified.nextSequenceReceive(ibcTest.portId, ibcTest.channelId);
                expect(response.nextSequenceReceive).toEqual(long_1.default.fromInt(1, true));
                expect(response.proofHeight).toBeDefined();
                expect(response.proofHeight).not.toBeNull();
                tmClient.disconnect();
            });
        });
        // Queries for ibc.connection
        describe("connection", () => {
            it("works", async () => {
                testutils_spec_1.pendingWithoutSimapp();
                const [client, tmClient] = await makeClientWithIbc(testutils_spec_1.simapp.tendermintUrl);
                const response = await client.ibc.unverified.connection(ibcTest.connectionId);
                expect(response.connection).toEqual(ibcTest.connection);
                expect(response.proofHeight).toBeDefined();
                expect(response.proofHeight).not.toBeNull();
                tmClient.disconnect();
            });
        });
        describe("connections", () => {
            it("works", async () => {
                testutils_spec_1.pendingWithoutSimapp();
                const [client, tmClient] = await makeClientWithIbc(testutils_spec_1.simapp.tendermintUrl);
                const response = await client.ibc.unverified.connections();
                expect(response.connections).toEqual([ibcTest.identifiedConnection]);
                expect(response.pagination).toBeDefined();
                expect(response.pagination).not.toBeNull();
                expect(response.height).toBeDefined();
                expect(response.height).not.toBeNull();
                tmClient.disconnect();
            });
        });
        describe("clientConnections", () => {
            it("works", async () => {
                testutils_spec_1.pendingWithoutSimapp();
                const [client, tmClient] = await makeClientWithIbc(testutils_spec_1.simapp.tendermintUrl);
                const response = await client.ibc.unverified.clientConnections(ibcTest.clientId);
                expect(response.connectionPaths).toEqual([ibcTest.connectionId]);
                expect(response.proofHeight).toBeDefined();
                expect(response.proofHeight).not.toBeNull();
                tmClient.disconnect();
            });
        });
    });
});
//# sourceMappingURL=ibc.spec.js.map