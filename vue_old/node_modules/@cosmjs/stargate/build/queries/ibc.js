"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupIbcExtension = void 0;
/* eslint-disable @typescript-eslint/naming-convention */
const encoding_1 = require("@cosmjs/encoding");
const math_1 = require("@cosmjs/math");
const long_1 = __importDefault(require("long"));
const channel_1 = require("../codec/ibc/core/channel/v1/channel");
const query_1 = require("../codec/ibc/core/channel/v1/query");
const query_2 = require("../codec/ibc/core/connection/v1/query");
const utils_1 = require("./utils");
function setupIbcExtension(base) {
    const rpc = utils_1.createRpc(base);
    // Use these services to get easy typed access to query methods
    // These cannot be used for proof verification
    const channelQueryService = new query_1.QueryClientImpl(rpc);
    const connectionQueryService = new query_2.QueryClientImpl(rpc);
    return {
        ibc: {
            channel: async (portId, channelId) => {
                // keeper: https://github.com/cosmos/cosmos-sdk/blob/3bafd8255a502e5a9cee07391cf8261538245dfd/x/ibc/04-channel/keeper/keeper.go#L55-L65
                // key: https://github.com/cosmos/cosmos-sdk/blob/ef0a7344af345882729598bc2958a21143930a6b/x/ibc/24-host/keys.go#L117-L120
                const key = encoding_1.toAscii(`channelEnds/ports/${portId}/channels/${channelId}`);
                const responseData = await base.queryVerified("ibc", key);
                return responseData.length ? channel_1.Channel.decode(responseData) : null;
            },
            packetCommitment: async (portId, channelId, sequence) => {
                // keeper: https://github.com/cosmos/cosmos-sdk/blob/3bafd8255a502e5a9cee07391cf8261538245dfd/x/ibc/04-channel/keeper/keeper.go#L128-L133
                // key: https://github.com/cosmos/cosmos-sdk/blob/ef0a7344af345882729598bc2958a21143930a6b/x/ibc/24-host/keys.go#L183-L185
                const key = encoding_1.toAscii(`commitments/ports/${portId}/channels/${channelId}/packets/${sequence}`);
                const responseData = await base.queryVerified("ibc", key);
                // keeper code doesn't parse, but returns raw
                return responseData;
            },
            packetAcknowledgement: async (portId, channelId, sequence) => {
                // keeper: https://github.com/cosmos/cosmos-sdk/blob/3bafd8255a502e5a9cee07391cf8261538245dfd/x/ibc/04-channel/keeper/keeper.go#L159-L166
                // key: https://github.com/cosmos/cosmos-sdk/blob/ef0a7344af345882729598bc2958a21143930a6b/x/ibc/24-host/keys.go#L153-L156
                const key = encoding_1.toAscii(`acks/ports/${portId}/channels/${channelId}/acknowledgements/${sequence}`);
                const responseData = await base.queryVerified("ibc", key);
                // keeper code doesn't parse, but returns raw
                return responseData;
            },
            nextSequenceReceive: async (portId, channelId) => {
                // keeper: https://github.com/cosmos/cosmos-sdk/blob/3bafd8255a502e5a9cee07391cf8261538245dfd/x/ibc/04-channel/keeper/keeper.go#L92-L101
                // key: https://github.com/cosmos/cosmos-sdk/blob/ef0a7344af345882729598bc2958a21143930a6b/x/ibc/24-host/keys.go#L133-L136
                const key = encoding_1.toAscii(`seqAcks/ports/${portId}/channels/${channelId}/nextSequenceAck`);
                const responseData = await base.queryVerified("ibc", key);
                return responseData.length ? math_1.Uint64.fromBytes(responseData).toNumber() : null;
            },
            unverified: {
                // Queries for ibc.core.channel.v1
                channel: async (portId, channelId) => {
                    const response = await channelQueryService.Channel({ portId: portId, channelId: channelId });
                    return response;
                },
                channels: async (paginationKey) => {
                    const request = {
                        pagination: utils_1.createPagination(paginationKey),
                    };
                    const response = await channelQueryService.Channels(request);
                    return response;
                },
                connectionChannels: async (connection, paginationKey) => {
                    const request = {
                        connection: connection,
                        pagination: utils_1.createPagination(paginationKey),
                    };
                    const response = await channelQueryService.ConnectionChannels(request);
                    return response;
                },
                packetCommitment: async (portId, channelId, sequence) => {
                    const response = await channelQueryService.PacketCommitment({
                        portId: portId,
                        channelId: channelId,
                        sequence: long_1.default.fromNumber(sequence, true),
                    });
                    return response;
                },
                packetCommitments: async (portId, channelId, paginationKey) => {
                    const request = {
                        channelId: channelId,
                        portId: portId,
                        pagination: utils_1.createPagination(paginationKey),
                    };
                    const response = await channelQueryService.PacketCommitments(request);
                    return response;
                },
                packetAcknowledgement: async (portId, channelId, sequence) => {
                    const response = await channelQueryService.PacketAcknowledgement({
                        portId: portId,
                        channelId: channelId,
                        sequence: long_1.default.fromNumber(sequence, true),
                    });
                    return response;
                },
                packetAcknowledgements: async (portId, channelId, paginationKey) => {
                    const response = await channelQueryService.PacketAcknowledgements({
                        portId: portId,
                        channelId: channelId,
                        pagination: utils_1.createPagination(paginationKey),
                    });
                    return response;
                },
                unreceivedPackets: async (portId, channelId, packetCommitmentSequences) => {
                    const response = await channelQueryService.UnreceivedPackets({
                        portId: portId,
                        channelId: channelId,
                        packetCommitmentSequences: packetCommitmentSequences.map((s) => long_1.default.fromNumber(s, true)),
                    });
                    return response;
                },
                unreceivedAcks: async (portId, channelId, packetAckSequences) => {
                    const response = await channelQueryService.UnreceivedAcks({
                        portId: portId,
                        channelId: channelId,
                        packetAckSequences: packetAckSequences.map((s) => long_1.default.fromNumber(s, true)),
                    });
                    return response;
                },
                nextSequenceReceive: async (portId, channelId) => {
                    const response = await channelQueryService.NextSequenceReceive({
                        portId: portId,
                        channelId: channelId,
                    });
                    return response;
                },
                // Queries for ibc.core.connection.v1
                connection: async (connectionId) => {
                    const response = await connectionQueryService.Connection({ connectionId: connectionId });
                    return response;
                },
                connections: async (paginationKey) => {
                    const request = {
                        pagination: utils_1.createPagination(paginationKey),
                    };
                    const response = await connectionQueryService.Connections(request);
                    return response;
                },
                clientConnections: async (clientId) => {
                    const response = await connectionQueryService.ClientConnections({ clientId: clientId });
                    return response;
                },
            },
        },
    };
}
exports.setupIbcExtension = setupIbcExtension;
//# sourceMappingURL=ibc.js.map